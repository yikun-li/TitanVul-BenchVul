"""
Main Vulnerability Fixing Detection Pipeline Orchestrator.

This module orchestrates the entire vulnerability fixing detection pipeline,
coordinating between all agents and managing the flow of data between components.
"""

import json
import time
import difflib
from typing import Dict, Any, List, Optional, Set, Tuple

from config.settings import ModelConfig, PipelineConfig, APICredentials
from api.openai_client import OpenAIClient
from api.anthropic_client import AnthropicClient
from agents.auditor_agent import AuditorAgent
from agents.critic_agent import CriticAgent
from agents.consensus_agent import ConsensusAgent
from utils.file_utils import FileManager
from utils.logging_utils import LoggerMixin


class VulnerabilityDetectionPipeline(LoggerMixin):
    """
    Main pipeline orchestrator for vulnerability fixing detection.

    Coordinates the execution of all pipeline agents and manages
    the flow of data between components for analyzing code changes.
    """

    def __init__(
            self,
            model_config: ModelConfig,
            pipeline_config: PipelineConfig,
            api_credentials: APICredentials
    ):
        """
        Initialize the vulnerability detection pipeline.

        Args:
            model_config: Configuration for the model and API
            pipeline_config: Configuration for pipeline behavior
            api_credentials: API credentials for different providers
        """
        self.model_config = model_config
        self.pipeline_config = pipeline_config

        # Initialize API client based on provider
        self.api_client = self._initialize_api_client(model_config, api_credentials)

        # Initialize agents
        self.auditor_agent = AuditorAgent(self.api_client)
        self.critic_agent = CriticAgent(self.api_client)
        self.consensus_agent = ConsensusAgent(self.api_client)

        # Initialize utilities
        self.file_manager = FileManager(pipeline_config.output_dir)

        self.logger.info(f"Pipeline initialized with {model_config.provider} provider and {model_config.model} model")

    def _initialize_api_client(self, model_config: ModelConfig, api_credentials: APICredentials):
        """
        Initialize the appropriate API client based on the provider.

        Args:
            model_config: Model configuration
            api_credentials: API credentials

        Returns:
            Initialized API client

        Raises:
            ValueError: If unsupported provider is specified
        """
        if model_config.provider == "openai":
            return OpenAIClient(
                api_key=api_credentials.openai_api_key,
                model=model_config.model,
                temperature=model_config.temperature,
                max_tokens=model_config.max_tokens
            )
        elif model_config.provider == "anthropic":
            return AnthropicClient(
                api_key=api_credentials.anthropic_api_key,
                model=model_config.model,
                temperature=model_config.temperature,
                max_tokens=model_config.max_tokens
            )
        else:
            raise ValueError(f"Unsupported model provider: {model_config.provider}")

    def create_code_diff(self, func_before: str, func_after: str, use_diff_format: bool = False) -> str:
        """
        Create code diff in the requested format.

        Args:
            func_before: Original function code
            func_after: Modified function code
            use_diff_format: Whether to use diff format or side-by-side format

        Returns:
            Formatted code diff string
        """
        if use_diff_format:
            # Generate ndiff format
            diff = difflib.ndiff(
                func_before.strip().splitlines(),
                func_after.strip().splitlines(),
            )
            return '\n'.join(diff)
        else:
            # Return original and revised separately
            return f"Original code snippet (code before changes):\n```\n{func_before}\n```\n\nRevised code snippet (code after changes):\n```\n{func_after}\n```"

    def run_three_agent_system(
            self,
            func_before: str,
            func_after: str,
            commit_message: str,
            cwe_info: str,
            use_diff_format: bool = False,
            include_commit_message: bool = True
    ) -> Dict[str, Any]:
        """
        Run the three-agent system: Auditor -> Critic -> Consensus.

        Args:
            func_before: Original function code
            func_after: Modified function code
            commit_message: Commit message providing context
            cwe_info: CWE information about the vulnerability
            use_diff_format: Whether to use diff format for code changes
            include_commit_message: Whether to include commit message in analysis

        Returns:
            Dictionary containing results from all three agents
        """
        self.logger.info("Starting three-agent vulnerability fixing detection analysis")

        # Prepare code diff
        code_diff = self.create_code_diff(func_before, func_after, use_diff_format)

        # Prepare commit message (only include if flag is set)
        commit_msg_for_analysis = commit_message if include_commit_message else ""

        # Prepare CWE info
        cwe_info_formatted = f"CWE-{cwe_info}" if cwe_info and cwe_info.isdigit() else cwe_info

        # Step 1: Auditor Agent
        self.logger.info("Running Auditor Agent analysis...")
        auditor_result = self.auditor_agent.analyze_code_changes(
            code_diff=code_diff,
            commit_message=commit_msg_for_analysis,
            cwe_info=cwe_info_formatted
        )

        # Step 2: Critic Agent
        self.logger.info("Running Critic Agent review...")
        critic_result = self.critic_agent.review_auditor_analysis(
            code_diff=code_diff,
            commit_message=commit_msg_for_analysis,
            cwe_info=cwe_info_formatted,
            auditor_output=auditor_result
        )

        # Step 3: Consensus Agent
        self.logger.info("Running Consensus Agent for final decision...")
        consensus_result = self.consensus_agent.make_final_decision(
            auditor_output=auditor_result,
            critic_output=critic_result
        )

        # Extract consensus score
        consensus_score = consensus_result.get('possibility_score', -1)

        # Compile all results
        results = {
            "auditor": auditor_result,
            "critic": critic_result,
            "consensus": consensus_result,
            "consensus_score": consensus_score,
            "pipeline_metadata": {
                "model_provider": self.model_config.provider,
                "model": self.model_config.model,
                "temperature": self.model_config.temperature,
                "analysis_timestamp": int(time.time()),
                "use_diff_format": use_diff_format,
                "include_commit_message": include_commit_message
            }
        }

        self.logger.info(f"Three-agent analysis completed. Consensus score: {consensus_score}")
        return results

    def analyze_single_sample(
            self,
            func_before: str,
            func_after: str,
            commit_message: str,
            cwe_id: str,
            use_diff_format: bool = False,
            include_commit_message: bool = True
    ) -> Dict[str, Any]:
        """
        Analyze a single code change sample.

        Args:
            func_before: Original function code
            func_after: Modified function code
            commit_message: Commit message providing context
            cwe_id: CWE identifier for the vulnerability
            use_diff_format: Whether to use diff format for code changes
            include_commit_message: Whether to include commit message in analysis

        Returns:
            Dictionary containing analysis results
        """
        self.logger.info(f"Analyzing sample with CWE-{cwe_id}")

        # Run the three-agent system
        results = self.run_three_agent_system(
            func_before=func_before,
            func_after=func_after,
            commit_message=commit_message,
            cwe_info=cwe_id,
            use_diff_format=use_diff_format,
            include_commit_message=include_commit_message
        )

        # Add sample metadata
        results['sample_metadata'] = {
            "func_before": func_before,
            "func_after": func_after,
            "commit_message": commit_message,
            "cwe_id": cwe_id
        }

        return results

    def process_csv_row(
            self,
            row: Dict[str, str],
            use_diff_format: bool = False,
            include_commit_message: bool = True
    ) -> Dict[str, Any]:
        """
        Process a single CSV row through the pipeline.

        Args:
            row: CSV row containing func_before, func_after, commit_message, cwe_id
            use_diff_format: Whether to use diff format for code changes
            include_commit_message: Whether to include commit message in analysis

        Returns:
            Dictionary containing analysis results formatted for CSV output
        """
        # Extract data from CSV row
        func_before = row.get('func_before', '').strip()
        func_after = row.get('func_after', '').strip()
        commit_message = row.get('commit_message', '').strip()
        cwe_id = row.get('cwe_id', '').strip()

        # Skip if no code changes
        if not func_before or not func_after:
            self.logger.warning("Skipping row with missing function code")
            return None

        # Run analysis
        results = self.analyze_single_sample(
            func_before=func_before,
            func_after=func_after,
            commit_message=commit_message,
            cwe_id=cwe_id,
            use_diff_format=use_diff_format,
            include_commit_message=include_commit_message
        )

        # Format results for CSV output
        csv_row = {
            'func_before': func_before,
            'func_after': func_after,
            'commit_message': commit_message,
            'cwe_id': cwe_id,
            'auditor_result': json.dumps(results['auditor']),
            'critic_result': json.dumps(results['critic']),
            'consensus_score': results['consensus_score'],
            'consensus_result': json.dumps(results['consensus']),
            'full_analysis': json.dumps(results)
        }

        return csv_row

    def extract_json_from_response(self, content: str) -> Dict[str, Any]:
        """
        Extract JSON from markdown code blocks or plain text.

        Args:
            content: Raw content from API response

        Returns:
            Parsed JSON data or raw response if parsing fails
        """
        import re

        # Try to extract JSON from markdown code blocks
        json_match = re.search(r'```(?:json)?\s*\n?(.*?)\n?```', content, re.DOTALL)
        if json_match:
            json_str = json_match.group(1).strip()
            try:
                return json.loads(json_str)
            except json.JSONDecodeError:
                pass

        # Try to parse the entire content as JSON
        try:
            return json.loads(content)
        except json.JSONDecodeError:
            pass

        # If all fails, return as raw response
        return {"raw_response": content}

    def get_pipeline_statistics(self) -> Dict[str, Any]:
        """
        Get statistics about the current pipeline state.

        Returns:
            Dictionary containing pipeline statistics
        """
        return {
            "pipeline_config": {
                "provider": self.model_config.provider,
                "model": self.model_config.model,
                "temperature": self.model_config.temperature,
                "output_directory": self.pipeline_config.output_dir,
                "pipeline_type": "vulnerability_fixing_detection"
            },
            "agent_count": 3,
            "agents": ["AuditorAgent", "CriticAgent", "ConsensusAgent"]
        }

    def validate_connection(self) -> bool:
        """
        Validate that the API client can connect to the service.

        Returns:
            True if connection is successful, False otherwise
        """
        return self.api_client.validate_connection()
