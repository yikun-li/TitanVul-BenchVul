"""
Security Auditor Agent for the Vulnerability Fixing Detection Pipeline.

This agent analyzes code changes to determine if they address security vulnerabilities.
It focuses on identifying security-related code changes and providing concrete evidence.
"""

import json
import re
from typing import Dict, Any, List

from api.base_client import BaseAPIClient
from utils.logging_utils import LoggerMixin


class AuditorAgent(LoggerMixin):
    """
    Agent responsible for analyzing code changes for security vulnerability fixes.

    This agent determines whether code changes address security vulnerabilities
    by analyzing code diffs and providing evidence-based assessments.
    """

    def __init__(self, api_client: BaseAPIClient):
        """
        Initialize the Auditor Agent.

        Args:
            api_client: API client for making model calls
        """
        self.api_client = api_client

    def analyze_code_changes(
            self,
            code_diff: str,
            commit_message: str,
            cwe_info: str
    ) -> Dict[str, Any]:
        """
        Analyze code changes to determine if they fix security vulnerabilities.

        Args:
            code_diff: The code diff showing changes
            commit_message: Commit message providing context
            cwe_info: CWE information about the vulnerability

        Returns:
            Dictionary containing analysis results
        """
        # Create the prompt messages
        messages = self._create_prompt_messages(code_diff, commit_message, cwe_info)

        # Make the API call
        response = self.api_client.call_model(messages, "Security Auditor")

        # Parse and validate the response
        analysis_result = self._parse_response(response)

        return analysis_result

    def _create_prompt_messages(
            self,
            code_diff: str,
            commit_message: str,
            cwe_info: str
    ) -> List[Dict[str, str]]:
        """
        Create the prompt messages for the API call.

        Args:
            code_diff: The code diff showing changes
            commit_message: Commit message providing context
            cwe_info: CWE information about the vulnerability

        Returns:
            List of messages for the API call
        """
        system_prompt = """You are an experienced security analyst reviewing a code change. Your task is to determine, based solely on the provided code diff and with reference to any commit message or CWE information, whether this code change is a fix for a security vulnerability.

* Focus on SECURITY-RELATED CODE CHANGES, not the quality of the fix.
* The commit message and CWE may give hints about what to look for, but you must find concrete evidence in the code itself.
* Identify the type of vulnerability fixed (if any), explain your reasoning, and clearly cite code snippets or locations that demonstrate the fix.
* Indicate whether and how the commit message or CWE info helped guide your search, but do not treat them as evidence.

Perform the following steps:

1. Review the code changes to determine if they address a security vulnerability.
2. If yes, identify the vulnerability type (CWE or description), and describe your reasoning.
3. Cite specific lines or code snippets that serve as concrete evidence of the fix.
4. Indicate if and how the commit message and/or CWE info helped guide your analysis.

**Respond in this exact JSON structure:**

{
  "is_vuln_fix": true/false,
  "vulnerability_type": "...", // CWE or descriptive type, or null if unknown
  "reason": "...",
  "code_evidence": [
    {
      "changed_lines": "...",
      "snippet": "..."
    }
  ],
  "used_commit_message": true/false,
  "used_cwe": true/false,
  "commit_message_hint": "...",
  "cwe_hint": "..."
}"""

        user_prompt = f"""You are a secure coding assistant. Based on the provided inputs, analyze the code changes and determine if they fix a security vulnerability.

**Code diff:**
{code_diff}

**CWE info:**
{cwe_info}

**Commit message:**
{commit_message}

Provide your analysis following the JSON structure specified in the system prompt."""

        return [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]

    def _parse_response(self, response: str) -> Dict[str, Any]:
        """
        Parse the API response and extract JSON data.

        Args:
            response: Raw response from the API

        Returns:
            Parsed JSON data as dictionary
        """
        try:
            # Try to parse as direct JSON first
            analysis_data = json.loads(response)
            return analysis_data
        except json.JSONDecodeError:
            # Try to extract JSON from code blocks
            json_match = re.search(r'```json\n(.*?)\n```', response, re.DOTALL)
            if json_match:
                try:
                    analysis_data = json.loads(json_match.group(1))
                    return analysis_data
                except json.JSONDecodeError:
                    pass

            # Try to find JSON in curly braces
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                try:
                    analysis_data = json.loads(json_match.group(0))
                    return analysis_data
                except json.JSONDecodeError:
                    pass

            # If all parsing attempts fail, return default response
            self.logger.error("Could not parse JSON from Auditor response. Raw response:")
            self.logger.error(response)

            # Return a default response if parsing fails
            analysis_data = {
                "is_vuln_fix": False,
                "vulnerability_type": None,
                "reason": "Failed to parse response",
                "code_evidence": [],
                "used_commit_message": False,
                "used_cwe": False,
                "commit_message_hint": "",
                "cwe_hint": "",
                "parse_error": "Could not parse JSON response from Auditor"
            }

            return analysis_data

    def extract_json_from_response(self, content: str) -> Dict[str, Any]:
        """
        Extract JSON from markdown code blocks or plain text.

        Args:
            content: Raw content from API response

        Returns:
            Parsed JSON data or raw response if parsing fails
        """
        # Try to extract JSON from markdown code blocks
        json_match = re.search(r'```(?:json)?\s*\n?(.*?)\n?```', content, re.DOTALL)
        if json_match:
            json_str = json_match.group(1).strip()
            try:
                return json.loads(json_str)
            except json.JSONDecodeError:
                pass

        # Try to parse the entire content as JSON
        try:
            return json.loads(content)
        except json.JSONDecodeError:
            pass

        # If all fails, return as raw response
        return {"raw_response": content}
